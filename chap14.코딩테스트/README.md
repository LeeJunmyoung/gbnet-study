# 코딩테스트

> 많은 기업이 개발자를 채용시 변별력을 위해 코딩테스트 단계가 있다.  
> 근데 실무를 하다 보면 똑같은 자료구조만 쓰게된다.  
> 알고리즘 문제를 받으면 쉽게 풀 수 있을거 같은데 막상 풀려면 뭔가 잘 안되더라...  
> 프로그래머스도 풀고 커랭크도 풀고 하는데 규칙적으로 잘 안되는 느낌.  
> 그래서 책을 하나 사봣당.  
> '이것이 취업을 위한 코딩 테스트다 with 파이썬' 저자 : 나동빈  
> 규칙적으로 책에 있는 문제와 이론을 정독해봐야겟다.  
> 2020-09-23 00시 51분

<br>

## 1. 복잡도
> 복잡도 얼마전에 관리자 그리드에서 너무 느리다고 개선해달라는 요구를 받았다.  
> 원인은 시간 복잡도 n^2 이더라  그래서 n으로 변경한 경험이 있다.  
> 코딩테스트때 효율성에서 항상 미끄러지는데 항상 감각적으로 문제를 풀었던거 같다.  
> 책에는 문제를 풀때 고려해야할 아래와 같은 내용이 있었다.  
> 책에서는 1000만 개를 기준으로 1초로 잡은거 같다. 실제로도 그런가??  
> 요새 cpu 1코어 기준 3ghz 1hz당 1회의 명령어를 처리한다면? 3 * 10 ^ 9  = 30억 ?
```
- 시간 제한이 1초인 문제에 대한 예시
1. N의 범위가 500인 경우        : 시간복잡도 n^3 알고리즘
2. N의 범위가 2,000인 경우      : 시간복잡도 n^2 알고리즘
3. N의 범위가 100,000의 경우    : 시간복잡도 nlogn 알고리즘
4. N의 범위가 10,000,000의 경우 : 시간복잡도 n 알고리즘

- 공간복잡도
코딩테스트 하면서 공간복잡도까지 고려한적은 기억에 없지만 책에 있으니 남겨본다
int a[1000]         : 4byte * 1000 = 4kb
int a[1000000]      : 4byte * 1000 * 1000 = 4mb
int a[1000][1000]   : 4kb * 4kb = 16mb
```

## 2. 그리디 알고리즘
> 매 순간 가장 좋아 보이는 것을 선택하며 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않는다.  
> 거스름돈 문제는 대표적인 그리디 알고리즘 문제이다.  
> 카운터에 500원, 100원, 50원 ,10원이 무제한으로 존재할 경우, 거슬러줘야 할돈이 N원일경우 거슬러줘야할 동전의 최소개수는???  

```
class GreedyCoinTest {
    public static void main(String[] args) {
        int n   = 1390; // 잔액
        int cnt = 0;    // 동전 수

        int[] coinArr = {500, 100, 50, 10};

        for(int coin : coinArr) {
            cnt += n / coin;
            n = n % coin;
        }

        System.out.println("동전의 개수 : " + cnt);
    }
}
```
  
## 3. 구현  
> 해당 책에서는 완전탐색, 시뮬레이션 유형을 모두 '구현' 유형으로 본다.  
> 완전탐색은 모든 경우의 수 계산, 시뮬레이션은 문제에서 제시한 알고리즘을 한단계씩 차례대로 직접 수행한다.  

### 3-1. 구현시 고려해야할 메모리 제약사항

- 정수형 종류에 따른 범위  

    정수형 종류 | 자료형 크기 | 자료형의 범위  
    ---|---|---|
    int|4바이트|-2,147,483,648 ~ 2,147,438,647  
    long|8바이트|-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807  
    BigInteger(클래스)|가변적|제한없음

- int 자료형 데이터의 개수에 따른 메모리 사용량

    데이터의 개수(리스트의 수)|메모리 사용량  
    ---|---
    1,000|약 4KB  
    1,000,000|약 4MB  
    10,000,000|약 40MB  
  

** 1초에 2,000만번의 연산을 수행한다고 가정하고 문제풀기
