# 코딩테스트

> 많은 기업이 개발자를 채용시 변별력을 위해 코딩테스트 단계가 있다.  
> 근데 실무를 하다 보면 똑같은 자료구조만 쓰게된다.  
> 알고리즘 문제를 받으면 쉽게 풀 수 있을거 같은데 막상 풀려면 뭔가 잘 안되더라...  
> 프로그래머스도 풀고 커랭크도 풀고 하는데 규칙적으로 잘 안되는 느낌.  
> 그래서 책을 하나 사봣당.  
> '이것이 취업을 위한 코딩 테스트다 with 파이썬' 저자 : 나동빈  
> 규칙적으로 책에 있는 문제와 이론을 정독해봐야겟다.  
> 2020-09-23 00시 51분

<hr>
<br>

## 1. 복잡도
> 복잡도 얼마전에 관리자 그리드에서 너무 느리다고 개선해달라는 요구를 받았다.  
> 원인은 시간 복잡도 n^2 이더라  그래서 n으로 변경한 경험이 있다.  
> 코딩테스트때 효율성에서 항상 미끄러지는데 항상 감각적으로 문제를 풀었던거 같다.  
> 책에는 문제를 풀때 고려해야할 아래와 같은 내용이 있었다.  
> 책에서는 1000만 개를 기준으로 1초로 잡은거 같다. 실제로도 그런가??  
> 요새 cpu 1코어 기준 3ghz 1hz당 1회의 명령어를 처리한다면? 3 * 10 ^ 9  = 30억 ?
```
- 시간 제한이 1초인 문제에 대한 예시
1. N의 범위가 500인 경우        : 시간복잡도 n^3 알고리즘
2. N의 범위가 2,000인 경우      : 시간복잡도 n^2 알고리즘
3. N의 범위가 100,000의 경우    : 시간복잡도 nlogn 알고리즘
4. N의 범위가 10,000,000의 경우 : 시간복잡도 n 알고리즘

- 공간복잡도
코딩테스트 하면서 공간복잡도까지 고려한적은 기억에 없지만 책에 있으니 남겨본다
int a[1000]         : 4byte * 1000 = 4kb
int a[1000000]      : 4byte * 1000 * 1000 = 4mb
int a[1000][1000]   : 4kb * 4kb = 16mb
```

<hr>
<br>

## 2. 그리디 알고리즘
> 매 순간 가장 좋아 보이는 것을 선택하며 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않는다.  
> 거스름돈 문제는 대표적인 그리디 알고리즘 문제이다.  
> 카운터에 500원, 100원, 50원 ,10원이 무제한으로 존재할 경우, 거슬러줘야 할돈이 N원일경우 거슬러줘야할 동전의 최소개수는???  

```
class GreedyCoinTest {
    public static void main(String[] args) {
        int n   = 1390; // 잔액
        int cnt = 0;    // 동전 수

        int[] coinArr = {500, 100, 50, 10};

        for(int coin : coinArr) {
            cnt += n / coin;
            n = n % coin;
        }

        System.out.println("동전의 개수 : " + cnt);
    }
}
```

<hr>
<br>
  
## 3. 구현  
> 해당 책에서는 완전탐색, 시뮬레이션 유형을 모두 '구현' 유형으로 본다.  
> 완전탐색은 모든 경우의 수 계산, 시뮬레이션은 문제에서 제시한 알고리즘을 한단계씩 차례대로 직접 수행한다.  

### 3-1. 구현시 고려해야할 메모리 제약사항

- 정수형 종류에 따른 범위  

    정수형 종류 | 자료형 크기 | 자료형의 범위  
    ---|---|---|
    int|4바이트|-2,147,483,648 ~ 2,147,438,647  
    long|8바이트|-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807  
    BigInteger(클래스)|가변적|제한없음

- int 자료형 데이터의 개수에 따른 메모리 사용량

    데이터의 개수(리스트의 수)|메모리 사용량  
    ---|---
    1,000|약 4KB  
    1,000,000|약 4MB  
    10,000,000|약 40MB  
  

** 1초에 2,000만번의 연산을 수행한다고 가정하고 문제풀기

<hr>
<br>

## 4. 탐색  
> 탐색이란 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정.   
> 프로그래밍에서는 그래프, 트리 등의 자료구조 안에서 탐색을 하는 문제를 자주다룬다.  
> 대표적인 탐색 알고리즘으로는 DFS, BFS를 꼽을 수 있다.  

### 4-1. 자료구조 그리고 재귀함수
> DFS, BFS 를 구현하려면 재귀함수와 자료구조를 이해해야 한다.

- 스택 : 선입 후출 구조 또는 후입 선출 구조.
- 큐 : 선입 선출 구조.
- 재귀함수 : 자기 자신을 호출하는 함수
```
팩토리얼 구현시
5! = 5 * 4 * 3 * 2 * 1
public int factorial(int n) {
    int result = 1;
    for(int num = 1; num <= n; num++) {
        result *= num;
    }
    return result;
}

public int recursiveFactorial(int n) {
    if(n <= 1) {
        return 1;
    }
    else {
        return n * recursiveFactorial(n-1)
    }
}
```
  
### 4-3. DFS
> DFS(Depth-First Search) 깊이 우선 탐색.  
> 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘.  
> 인접 행렬 : 2차원 배열로 그래프의 연결 관계를 표현하는 방식.  
> 인접 리스트 : 리스트로 그래프의 연결 관계를 표현하는 방식  

#### 동작과정
1. 탐색 시작 노드를 스택에 삽입하고 방문처리를 한다.  
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문처리를 함.  
3. 방문 하지 않은 인접노드가 없으면 스택에서 최상단 노드를 뺌.  
4. 2,3번 과정이 안될때까지 반복.

### 4-4. BFS
> BFS(Breadth-First Search) 너비 우선 탐색.  
> 가까운 노드 부터 탐색하는 알고리즘.  
> 트리 구조로 치면 같은 레벨을 우선적으로 탐색

#### 동작과정
1. 탐색 시작 노드를 큐에 삽입하고 방문처리를 한다.  
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입 하고 방문처리 함.  
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복.  

<hr>
<br>