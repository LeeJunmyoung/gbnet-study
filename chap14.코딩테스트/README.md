# 코딩테스트

> 많은 기업이 개발자를 채용시 변별력을 위해 코딩테스트 단계가 있다.  
> 근데 실무를 하다 보면 똑같은 자료구조만 쓰게된다.  
> 알고리즘 문제를 받으면 쉽게 풀 수 있을거 같은데 막상 풀려면 뭔가 잘 안되더라...  
> 프로그래머스도 풀고 커랭크도 풀고 하는데 규칙적으로 잘 안되는 느낌.  
> 그래서 책을 하나 사봣당.  
> '이것이 취업을 위한 코딩 테스트다 with 파이썬' 저자 : 나동빈  
> 규칙적으로 책에 있는 문제와 이론을 정독해봐야겟다.  
> 2020-09-23 00시 51분

<hr>
<br>

## 1. 복잡도
> 복잡도 얼마전에 관리자 그리드에서 너무 느리다고 개선해달라는 요구를 받았다.  
> 원인은 시간 복잡도 n^2 이더라  그래서 n으로 변경한 경험이 있다.  
> 코딩테스트때 효율성에서 항상 미끄러지는데 항상 감각적으로 문제를 풀었던거 같다.  
> 책에는 문제를 풀때 고려해야할 아래와 같은 내용이 있었다.  
> 책에서는 1000만 개를 기준으로 1초로 잡은거 같다. 실제로도 그런가??  
> 요새 cpu 1코어 기준 3ghz 1hz당 1회의 명령어를 처리한다면? 3 * 10 ^ 9  = 30억 ?
```
- 시간 제한이 1초인 문제에 대한 예시
1. N의 범위가 500인 경우        : 시간복잡도 n^3 알고리즘
2. N의 범위가 2,000인 경우      : 시간복잡도 n^2 알고리즘
3. N의 범위가 100,000의 경우    : 시간복잡도 nlogn 알고리즘
4. N의 범위가 10,000,000의 경우 : 시간복잡도 n 알고리즘

- 공간복잡도
코딩테스트 하면서 공간복잡도까지 고려한적은 기억에 없지만 책에 있으니 남겨본다
int a[1000]         : 4byte * 1000 = 4kb
int a[1000000]      : 4byte * 1000 * 1000 = 4mb
int a[1000][1000]   : 4kb * 4kb = 16mb
```

<hr>
<br>

## 2. 그리디 알고리즘
> 매 순간 가장 좋아 보이는 것을 선택하며 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않는다.  
> 거스름돈 문제는 대표적인 그리디 알고리즘 문제이다.  
> 카운터에 500원, 100원, 50원 ,10원이 무제한으로 존재할 경우, 거슬러줘야 할돈이 N원일경우 거슬러줘야할 동전의 최소개수는???  

```
class GreedyCoinTest {
    public static void main(String[] args) {
        int n   = 1390; // 잔액
        int cnt = 0;    // 동전 수

        int[] coinArr = {500, 100, 50, 10};

        for(int coin : coinArr) {
            cnt += n / coin;
            n = n % coin;
        }

        System.out.println("동전의 개수 : " + cnt);
    }
}
```

<hr>
<br>
  
## 3. 구현  
> 해당 책에서는 완전탐색, 시뮬레이션 유형을 모두 '구현' 유형으로 본다.  
> 완전탐색은 모든 경우의 수 계산, 시뮬레이션은 문제에서 제시한 알고리즘을 한단계씩 차례대로 직접 수행한다.  

### 3-1. 구현시 고려해야할 메모리 제약사항

- 정수형 종류에 따른 범위  

    정수형 종류 | 자료형 크기 | 자료형의 범위  
    ---|---|---|
    int|4바이트|-2,147,483,648 ~ 2,147,438,647  
    long|8바이트|-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807  
    BigInteger(클래스)|가변적|제한없음

- int 자료형 데이터의 개수에 따른 메모리 사용량

    데이터의 개수(리스트의 수)|메모리 사용량  
    ---|---
    1,000|약 4KB  
    1,000,000|약 4MB  
    10,000,000|약 40MB  
  

** 1초에 2,000만번의 연산을 수행한다고 가정하고 문제풀기

<hr>
<br>

## 4. 탐색  
> 탐색이란 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정.   
> 프로그래밍에서는 그래프, 트리 등의 자료구조 안에서 탐색을 하는 문제를 자주다룬다.  
> 대표적인 탐색 알고리즘으로는 DFS, BFS를 꼽을 수 있다.  

### 4-1. 자료구조 그리고 재귀함수
> DFS, BFS 를 구현하려면 재귀함수와 자료구조를 이해해야 한다.

- 스택 : 선입 후출 구조 또는 후입 선출 구조.
- 큐 : 선입 선출 구조.
- 재귀함수 : 자기 자신을 호출하는 함수
```
팩토리얼 구현시
5! = 5 * 4 * 3 * 2 * 1
public int factorial(int n) {
    int result = 1;
    for(int num = 1; num <= n; num++) {
        result *= num;
    }
    return result;
}

public int recursiveFactorial(int n) {
    if(n <= 1) {
        return 1;
    }
    else {
        return n * recursiveFactorial(n-1)
    }
}
```
  
### 4-3. DFS
> DFS(Depth-First Search) 깊이 우선 탐색.  
> 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘.  
> 인접 행렬 : 2차원 배열로 그래프의 연결 관계를 표현하는 방식.  
> 인접 리스트 : 리스트로 그래프의 연결 관계를 표현하는 방식  

#### 동작과정
1. 탐색 시작 노드를 스택에 삽입하고 방문처리를 한다.  
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문처리를 함.  
3. 방문 하지 않은 인접노드가 없으면 스택에서 최상단 노드를 뺌.  
4. 2,3번 과정이 안될때까지 반복.

### 4-4. BFS
> BFS(Breadth-First Search) 너비 우선 탐색.  
> 가까운 노드 부터 탐색하는 알고리즘.  
> 트리 구조로 치면 같은 레벨을 우선적으로 탐색

#### 동작과정
1. 탐색 시작 노드를 큐에 삽입하고 방문처리를 한다.  
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입 하고 방문처리 함.  
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복.  

<hr>
<br>

## 5. 정렬 
> 정렬(sort)란 데이터를 특정한 기준에 따라서 순서대로 나열하는 것.  

### 5-1. 선택 정렬
>  데이터가 무작위로 여러개 있을 경우  
> 이중 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고  
> 그 다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복한다.
> 이 방법은 매번 '가장 작은 것을 선택' 하는 선택 정렬 알고리즘 이다.  
> 시간 복잡도 N^2

```
데이터
[7, 5, 9, 0, 3, 1] 

1step : [0, 5, 9, 7, 3, 1]
2step : [0, 1, 9, 7, 3, 5]
3step : [0, 1, 3, 7, 9, 5]
4step : [0, 1, 3, 5, 9, 7]
5step : [0, 1, 3, 5, 7, 9]
6step : [0, 1, 3, 5, 7, 9] 

public static void main(String[] args) {
    int[] arr = {7, 5, 9, 0, 3, 1};

    for(int i = 0; i < arr.length; i++) {
        int minIndex = i;

        for(int num = i + 1; num < arr.length; num++) {
            if(arr[minIndex] > arr[num]) {
                minIndex = num;
            }
        }
        int temp        = arr[i];
        arr[i]          = arr[minIndex];
        arr[minIndex]   = temp;
        
        System.out.print(String.format("%d step : ", i+1));
        for(int k : arr) {
            System.out.print(k + " ");
        }
        System.out.println();
    }
}
```

### 5-2. 삽입정렬  
> 삽입 정렬은 필요할 때만 위치를 바꾸므로 '데이터가 거의 정렬 되어 있을 때' 훨씬 효율적이다.  
> 선택 정렬은 현재 데이터의 상태와 상관없이 무조건 모든 원소를 비교하고 바꾸는 반면 삽입정렬은 트정한 데이터를 적절한 위치에 삽입한다는 의미에서 '삽입 정렬'이라고 부른다.  
> 정렬되어 있는 데이터 리스트에서 적절한 위치를 찾은 뒤, 해당 위치에 삽입된다는 점이 특징이다.  
> 시간 복잡도는 N^2 이지만, 이미 정렬 되어 있는 경우 1회만 비교 하므로 N이된다. 최악의 경우 N^2가 된다.
> 거의 정렬이 되어 있는 경우에는 퀵정렬 등 여타 정렬 알고리즘을 이용하는 것보다 삽입정렬을 이용하는게 좋을 수 도 있다.

```
데이터
[7, 5, 9, 0, 3, 1]

1 step : 5, 7, 9, 0, 3, 1
2 step : 5, 7, 9, 0, 3, 1
3 step : 0, 5, 7, 9, 3, 1
4 step : 0, 3, 5, 7, 9, 1
5 step : 0, 1, 3, 5, 7, 9

public static void main(String[] args) {
    int[] arr = {7, 5, 9, 0, 3, 1};
    
    for(int i = 1; i < arr.length; i++){
        int temp = arr[i];
        int j;
        for(j = i-1; j >= 0 && temp < arr[j]; j--){
            arr[j+1] = arr[j];
        }
        arr[j+1] = temp;
        System.out.print(String.format("%d step : ", i));
        for(int num : arr) {
            System.out.print(num + " ");
        }
        System.out.println();
    }
}
```

### 5-3. 퀵 정렬
> 퀵 정렬은 기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작한다.  
> 시간복잡도는 최악의 경우 N^2, 평균적으로 N log N이다.  

#### 과정
1. 리스트 가운데서 하나의 원소를 고른다. 이렇게 고른 원소를 피벗이라고 한다.  
2. 피벗 앞에는 피벗보다 값이 작은 모든 원소들이 오고, 피벗 뒤에는 피벗보다 값이 큰 모든 원소들이 오도록 피벗을 기준으로 리스트를 둘로 나눈다. 이렇게 리스트를 둘로 나누는 것을 분할이라고 한다. 분할을 마친 뒤에 피벗은 더 이상 움직이지 않는다.  
3. 분할된 두 개의 작은 리스트에 대해 재귀(Recursion)적으로 이 과정을 반복한다. 재귀는 리스트의 크기가 0이나 1이 될 때까지 반복된다.

    ![퀵 정렬](./img/quick_sort.gif)

```
public void quickSort(int[] arr, int left, int right) {
    int i, j, pivot, tmp;
    if (left < right) {
        i = left;   j = right;
        pivot = arr[(left+right)/2];
        //분할 과정
        while (i < j) {
            while (arr[j] > pivot) j--;
            // 이 부분에서 arr[j-1]에 접근해서 익셉션 발생가능함.
            while (i < j && arr[i] < pivot) i++;

            tmp = arr[i];
            arr[i] = arr[j];
            arr[j] = tmp;
        }
        //정렬 과정
        quickSort(arr, left, i - 1);
        quickSort(arr, i + 1, right);
    }
}
```